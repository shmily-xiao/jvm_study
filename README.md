# jvm_study

-- 
https://www.cnblogs.com/wade-luffy/p/5969418.html

偏向锁：
  无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。锁可以升级但是不能降级。
  大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。
|---|---|
偏向锁	| 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距	| 如果线程间存在锁竞争，会带来额外的锁撤销的消耗	| 适用于只有一个线程访问同步块场景
轻量级 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间,锁占用时间很短
重量级锁 | 线程竞争不使用自旋，不会消耗CPU	| 线程阻塞，响应时间缓慢	| 追求吞吐量,锁占用时间较长
  
偏向线程id：
  在对象的mark word 里面存放偏向的那个线程的id

偏向时间戳：
  JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier）
  

# OOM
在 堆、虚拟机栈和本地方法栈、方法区、运行时常量池（metaspaceSize）、本机直接内存（反射使用Unsafe::allocateMemory分配内存） 都可能会出现OOM或者是StackOverflowError。
